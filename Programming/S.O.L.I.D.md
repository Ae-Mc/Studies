# **S**ingle responsibility principle *(Принцип единой ответственности)*

> ***У класса должен быть только один мотив для изменения***

Каждый класс должен отвечать только за одну часть функциональности программы,
причём она должна быть полностью инкапсулирована в этот класс (скрыта внутри
класса)

Главная идея — борьба со сложностью. Программа делится на множество простых
компонентов, которые легко воспринимать по отдельности.

# **O**pen/closed principle *(Принцип открытости/закрытости)*

> ***Расширяйте классы, но не изменяйте их первоначальный код***

Классы должны быть открыты для расширения, но закрыты для изменения

Главная идея состоит в том, чтобы не ломать существующий код при внесении
изменений в программу

Класс можно назвать открытым для расширения, если есть возможность расширить набор его
операций или добавить к нему новые поля, создав собственный подкласс

Одновременно, класс можно назвать закрытым или законченным, если его интерфейс
уже окончательно определён и не будет изменяться в будущем

# **L**iskov substitution principle *(Принцип подстановки Лисков)*

> ***Подклассы должны дополнять, а не замещать поведение базового класса***

Подклассы должны создаваться таким образом, чтобы их объекты можно было бы
подставлять вместо объектов базового класса, не ломая при этом функциональности
клиентского кода

Это достижимо при соблюдении следующих правил:
* **Типы параметров метода подкласса должны *совпадать* или быть *более
абстрактными*, чем типы параметров базового класса.** Например:
    * Базовый класс содержит метод `feed(Cat c)`, который умеет кормить
домашних котов. Клиентский код это знает и всегда передаёт в метод кота
    * **Хорошо:** Был создан подкласс, в котором метод кормёжки был
переопределён так, чтобы накормить любое животное: `feed(Animal a)`. Если
подставить этот подкласс в клиентский код, то ничего страшного не произойдёт.
Клиентский код подаст в метод кота, но метод умеет кормить всех животных,
поэтому накормит и кота
    * **Плохо:** Был создан другой подкласс, в котором метод умеет кормить
только бенгальскую породу котов (подкласс котов): `feed(BengalCat c)`.
Клиентский код всё также подаст в метод обычного кота. Но метод умеет кормить
только бенгалов, поэтому не сможет отработать, сломав клиентский код

* **Тип возвращаемого значения метода подкласса должен *совпадать* или быть
*подтипом* возвращаемого значения базового метода.**
То же, что и в предыдущим пункте но наоборот. Например:
    * Базовый метод: `buyCat() -> Cat`. Клиентский код ожидает на выходе любого
кота
    * **Хорошо:** Метод подкласса: `buyCat() -> BengalCat`. Клиентский код
получит бенгальского кота, который является котом, поэтому всё будет хорошо
    * **Плохо:** Метод подкласса: `buyCat() -> Animal`. Клиентский код
сломается, так как это непонятное животное (возможно, динозавр) не поместится
в ящике-переноске для кота

* **Метод не должен вызывать исключения, которые не свойственны базовому
методу.** Типы исключений должны совпадать или быть подтипами исключений,
которые вызывает базовый метод. Блоки обработки исключений в клиентском коде
нацелены на конкретные типы исключений, вызываемые базовым методом. Поэтому
неожиданное исключение вызванное подклассом, может проскочить сквозь
обработчики клиентского кода и обрушить программу

* **Метод не должен ужесточать *предусловия*.** Например, базовый метод
работает с параметром целочисленного типа. Если подкласс требует, чтобы
значение этого параметра к тому же было больше нуля, то это ужесточает
предусловия. Клиентский код, который до этого отлично работал, подавая в метод
отрицательные числа, теперь сломается с объектом подкласса

* **Метод не должен ослаблять *постусловия*.** Например, базовый метод требует,
чтобы по завершению метода все подключения к базе данных были бы закрыты, а
подкласс оставляет эти подключения открытыми, чтобы потом повторно их
использовать. Но клиентский код базового класса об этом не знает. Он может
завершить программу сразу после вызова метода, оставив запущенные
процессы-призраки в системе

* **Набор условий, при которых объект имеет смысл, должен остаться без
изменений**

* **Подкласс не должен изменять значения приватных полей базового класса**

# **I**nterface segregation principle *(Принцип разделения интерфейса)*

> ***Клиенты не должны зависеть от методов, которые они не используют***

Нужно стремиться к тому, чтобы интерфейсы были достаточно узкими, чтобы классам
не приходилось реализовывать избыточное поведение. Т. е. слишком «толстые»
интерфейсы необходимо разделить на более маленькие и специфические, чтобы
клиенты маленьких интерфейсов знали только о методах, которые необходимы им в
работе

# **D**ependency inversion principle *(Принцип инверсии зависимостей)*

> ***Классы верхних уровней не должны зависеть от классов нижних уровней.  
> Оба должны зависеть от абстракций.  
> Абстракции не должны зависеть от деталей.  
> Детали должны зависеть от абстракций***

Обычно, при проектировании программ можно выделить два уровня классов.
* Классы нижнего уровня реализуют базовые операции вроде работы с диском,
передачи данных по сети, подключению к базе данных и прочее.
* Классы высокого уровня содержат сложную бизнес-логику програимы, которая
опирается на классы низкого уровня дляиосуществления более простых операций.

Зачастую, люди сперва проектируют классы нижнего уровня, а только потом берутся
за верхний уровень. При таком подходе классы бизнес-логики становятся
зависимыми от более примитивных низкоуровневых классов. Каждое изменения в
низкоуровневом классе может затронуть классы бизнес-логики, которые его
используют.

Принцип инверсии зависимостей предлагает
изменить направление, в котором происходит
проектирование.
1. Для начала нужно описать интерфейс низкоуровневых операций, которые нужны
классу бизнес-логики
2. Это позволит убрать зависимость класса бизнес-логики от конкретного
низкоуровневого класса, заменив её «мягкой» зависимостью от интерфейса.
3. Низкоуровневый класс, в свою очередь, станет зависимый от интерфейса,
определённого бизнес-логикой.

Принцип инверсии зависимостей часто идёт в
ногу с принципом открытости/закрытости: вы
сможете расширять низкоуровневые классы и
использовать их вместе с классами бизнес-
логики, не изменяя код последних.
